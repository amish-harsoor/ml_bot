import pandas as pd
import numpy as np

def compute_rsi(series, period=14):
    delta = series.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss
    return 100 - (100 / (1 + rs))

def compute_macd(series, fast=12, slow=26, signal=9):
    exp1 = series.ewm(span=fast, adjust=False).mean()
    exp2 = series.ewm(span=slow, adjust=False).mean()
    macd = exp1 - exp2
    signal_line = macd.ewm(span=signal, adjust=False).mean()
    return macd, signal_line

def compute_bollinger(series, window=20, num_std=2):
    sma = series.rolling(window=window).mean()
    std = series.rolling(window=window).std()
    upper = sma + (std * num_std)
    lower = sma - (std * num_std)
    width = (upper - lower) / sma
    return upper, lower, width

def compute_atr(df, period=14):
    high_low = df['High'] - df['Low']
    high_close = np.abs(df['High'] - df['Close'].shift())
    low_close = np.abs(df['Low'] - df['Close'].shift())
    ranges = pd.concat([high_low, high_close, low_close], axis=1)
    true_range = ranges.max(axis=1)
    return true_range.rolling(window=period).mean()

def compute_stochastic(df, k_window=14, d_window=3):
    low_min = df['Low'].rolling(window=k_window).min()
    high_max = df['High'].rolling(window=k_window).max()
    k = 100 * ((df['Close'] - low_min) / (high_max - low_min))
    d = k.rolling(window=d_window).mean()
    return k, d

def add_features(df: pd.DataFrame):
    df = df.copy()
    
    # 1. Flatten MultiIndex if necessary
    if isinstance(df.columns, pd.MultiIndex):
        df.columns = df.columns.get_level_values(0)

    # 2. Basic Price Features
    # Use Log Returns for better statistical properties
    df['Log_Ret'] = np.log(df['Close'] / df['Close'].shift(1))
    df['High_Low_Pct'] = (df['High'] - df['Low']) / df['Close']
    df['Close_Open_Pct'] = (df['Close'] - df['Open']) / df['Open']
    
    # 3. Advanced Technical Indicators
    
    # RSI
    df['RSI'] = compute_rsi(df['Close'])
    
    # MACD
    df['MACD'], df['MACD_Signal'] = compute_macd(df['Close'])
    df['MACD_Hist'] = df['MACD'] - df['MACD_Signal']
    
    # Bollinger Bands
    df['BB_Upper'], df['BB_Lower'], df['BB_Width'] = compute_bollinger(df['Close'])
    df['BB_Pct_B'] = (df['Close'] - df['BB_Lower']) / (df['BB_Upper'] - df['BB_Lower'])
    
    # ATR (Volatility)
    df['ATR'] = compute_atr(df)
    
    # Stochastic Oscillator
    df['Stoch_K'], df['Stoch_D'] = compute_stochastic(df)
    
    # CCI (Commodity Channel Index)
    tp = (df['High'] + df['Low'] + df['Close']) / 3
    sma_tp = tp.rolling(20).mean()
    mean_dev = tp.rolling(20).apply(lambda x: np.abs(x - x.mean()).mean())
    df['CCI'] = (tp - sma_tp) / (0.015 * mean_dev)

    # 4. Volume Features
    # OBV (On-Balance Volume)
    df['OBV'] = (np.sign(df['Close'].diff()) * df['Volume']).fillna(0).cumsum()
    # Volume vs Moving Average
    df['Vol_SMA_20'] = df['Volume'].rolling(20).mean()
    df['Vol_Ratio'] = df['Volume'] / df['Vol_SMA_20']

    # 5. Interaction & Statistical Features
    # Distance from SMAs
    for window in [10, 50, 200]:
        sma = df['Close'].rolling(window=window).mean()
        df[f'Dist_SMA_{window}'] = (df['Close'] - sma) / sma

    # Rolling Statistical Features (Skewness/Kurtosis of returns)
    df['Roll_Skew'] = df['Log_Ret'].rolling(30).skew()
    df['Roll_Kurt'] = df['Log_Ret'].rolling(30).kurt()

    # 6. Lag Features (The "Memory" of the market)
    # We lag specific high-value features, not just returns
    for lag in [1, 2, 3, 5]:
        df[f'Log_Ret_Lag_{lag}'] = df['Log_Ret'].shift(lag)
        df[f'RSI_Lag_{lag}'] = df['RSI'].shift(lag)
        df[f'Vol_Ratio_Lag_{lag}'] = df['Vol_Ratio'].shift(lag)

    # 7. Target Generation
    # 1 if Next Close > Current Close, else 0
    df['Target'] = (df['Close'].shift(-1) > df['Close']).astype(int)

    # Drop NaNs generated by rolling windows (we need at least ~200 rows of history for SMA_200)
    return df.dropna()
